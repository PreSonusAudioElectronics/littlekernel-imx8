/*
 * Copyright 2021 NXP
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include <app.h>
#include <err.h>
#include <string.h>
#include <malloc.h>
#include <dev/class/sai.h>
#include <dev/class/adc.h>
#include <dev/class/dac.h>
#include <kernel/spinlock.h>
#include <kernel/event.h>

#include <lib/appargs.h>
#include <dev/interrupt.h>
#include <trace.h>
#include <delay.h>

#include <math.h>

#define LOCAL_TRACE 5

#define APP_SAI5_BUSID 5
#define APP_SAI3_BUSID 3
#define APP_PCM186X_BUSID 18
#define APP_PCM512X_BUSID 51
#define APP_WM8524_BUSID 1

#define REC_AUDIO_SRATE 44100 /* default sampling rate */
#define REC_AUDIO_CHANNELS 2
#define REC_AUDIO_BITWIDTH 32
#define REC_FRAME_BYTES (REC_AUDIO_CHANNELS * REC_AUDIO_BITWIDTH / 8)
#define REC_PERIOD_SIZE 128
#define REC_DMA_PERIOD_BYTES (REC_PERIOD_SIZE * REC_FRAME_BYTES)
#define REC_AUDIO_PERIOD_BYTES REC_DMA_PERIOD_BYTES


#define PLAY_AUDIO_SRATE 44100 /* default sampling rate */
#define PLAY_AUDIO_CHANNELS 2
#define PLAY_AUDIO_BITWIDTH 16
#define PLAY_FRAME_BYTES (PLAY_AUDIO_CHANNELS * PLAY_AUDIO_BITWIDTH / 8)
#define PLAY_PERIOD_SIZE 128
#define PLAY_DMA_PERIOD_BYTES (PLAY_PERIOD_SIZE * PLAY_FRAME_BYTES)
#define PLAY_AUDIO_PERIOD_BYTES PLAY_DMA_PERIOD_BYTES

#define PLAY_LENGTH_MS (10 * 1000)

#define DTMF_AUDIO_SRATE 44100 /* default sampling rate */
#define DTMF_AUDIO_BITWIDTH 32
#define DTMF_TONE_DURATION_MS 120

#if WITH_LIB_CONSOLE

#include <lib/console.h>

static void generate_sinewave(uint32_t *buf, int lfreq, int rfreq, int samplerate)
{
    int i;
    ssize_t nsamples = samplerate * DTMF_TONE_DURATION_MS / 1000;
    for (i = 0; i < nsamples; i++) {
        double v1, v2;
        int32_t w1, w2;

        v1 = 0.5 * sin(i * 2 * 3.141592654 * lfreq / samplerate);
        w1 = (int32_t)(v1 * ((1 << 30) - 1));
        v2 = 0.5 * sin(i * 2 * 3.141592654 * rfreq / samplerate);
        w2 = (int32_t)(v2 * ((1 << 30) - 1));
        *buf++ = w1;
        *buf++ = w2;
    }
}

static void get_dtmf_freqs(char key, int *freq1, int *freq2)
{
    switch (key) {
        case '1':
        case '2':
        case '3':
        case 'A':
            /* 697 Hz */
            *freq1 = 697;
            break;

        case '4':
        case '5':
        case '6':
        case 'B':
            /* 770 Hz */
            *freq1 = 770;
            break;

        case '7':
        case '8':
        case '9':
        case 'C':
            /* 852 Hz */
            *freq1 = 852;
            break;

        case '*':
        case '0':
        case '#':
        case 'D':
            /* 941 Hz */
            *freq1 = 941;
            break;
    }

    switch (key) {
        case '1':
        case '4':
        case '7':
        case '*':
            /* 1209 Hz */
            *freq2 = 1209;
            break;

        case '2':
        case '5':
        case '8':
        case '0':
            /* 1336 Hz */
            *freq2 = 1336;
            break;

        case '3':
        case '6':
        case '9':
        case '#':
            /* 1477 Hz */
            *freq2 = 1477;
            break;

        case 'A':
        case 'B':
        case 'C':
        case 'D':
            /* 1633 Hz */
            *freq2 = 1633;
            break;
    }
}

static void generate_dtmf_tone(uint32_t *buf, char lkey, char rkey, int samplerate)
{
    int i;
    int lfreq1 = 0, lfreq2 = 0, rfreq1 = 0, rfreq2 = 0;
    uint32_t *buf2;
    ssize_t buf_size = samplerate * 2 * 4 * DTMF_TONE_DURATION_MS / 1000;

    /* buffer 40ms, 2 channels, 32 bits */
    buf2 = malloc(buf_size);
    ASSERT(buf2);

    /* Get dtmf frequencies for left and right channels */
    get_dtmf_freqs(lkey, &lfreq1, &lfreq2);
    get_dtmf_freqs(rkey, &rfreq1, &rfreq2);

    /* Fill primary sinewave */
    generate_sinewave(buf, lfreq1, rfreq1, samplerate);

    /* Add secondary sinewave */
    generate_sinewave(buf2, lfreq2, rfreq2, samplerate);

    /* mix buf and buf2 */
    for (i = 0; i < buf_size / 4; i ++) {
        buf[i] += buf2[i];
    }

    free(buf2);
}

static uint16_t sinewave[] =
{
  0x0000, 0x0000, 0x03ec, 0x03ec, 0x07d5, 0x07d5, 0x0bb6, 0x0bb6, 0x0f8c, 0x0f8c, 0x1353, 0x1353, 0x1708, 0x1708, 0x1aa6, 0x1aa6,
  0x1e2b, 0x1e2b, 0x2192, 0x2192, 0x24d9, 0x24d9, 0x27fd, 0x27fd, 0x2afa, 0x2afa, 0x2dce, 0x2dce, 0x3075, 0x3075, 0x32ee, 0x32ee,
  0x3536, 0x3536, 0x374a, 0x374a, 0x392a, 0x392a, 0x3ad2, 0x3ad2, 0x3c41, 0x3c41, 0x3d77, 0x3d77, 0x3e71, 0x3e71, 0x3f2f, 0x3f2f,
  0x3fb0, 0x3fb0, 0x3ff4, 0x3ff4, 0x3ffa, 0x3ffa, 0x3fc3, 0x3fc3, 0x3f4e, 0x3f4e, 0x3e9c, 0x3e9c, 0x3dae, 0x3dae, 0x3c84, 0x3c84,
  0x3b20, 0x3b20, 0x3983, 0x3983, 0x37af, 0x37af, 0x35a5, 0x35a5, 0x3367, 0x3367, 0x30f8, 0x30f8, 0x2e59, 0x2e59, 0x2b8e, 0x2b8e,
  0x2899, 0x2899, 0x257d, 0x257d, 0x223d, 0x223d, 0x1edb, 0x1edb, 0x1b5c, 0x1b5c, 0x17c3, 0x17c3, 0x1413, 0x1413, 0x104f, 0x104f,
  0x0c7c, 0x0c7c, 0x089c, 0x089c, 0x04b5, 0x04b5, 0x00c9, 0x00c9, 0xfcdd, 0xfcdd, 0xf8f3, 0xf8f3, 0xf510, 0xf510, 0xf137, 0xf137,
  0xed6d, 0xed6d, 0xe9b4, 0xe9b4, 0xe611, 0xe611, 0xe287, 0xe287, 0xdf1a, 0xdf1a, 0xdbcc, 0xdbcc, 0xd8a1, 0xd8a1, 0xd59c, 0xd59c,
  0xd2c0, 0xd2c0, 0xd00f, 0xd00f, 0xcd8d, 0xcd8d, 0xcb3b, 0xcb3b, 0xc91c, 0xc91c, 0xc732, 0xc732, 0xc57f, 0xc57f, 0xc404, 0xc404,
  0xc2c2, 0xc2c2, 0xc1bc, 0xc1bc, 0xc0f2, 0xc0f2, 0xc065, 0xc065, 0xc015, 0xc015, 0xc002, 0xc002, 0xc02d, 0xc02d, 0xc096, 0xc096,
  0xc13c, 0xc13c, 0xc21e, 0xc21e, 0xc33c, 0xc33c, 0xc494, 0xc494, 0xc626, 0xc626, 0xc7ef, 0xc7ef, 0xc9ef, 0xc9ef, 0xcc22, 0xcc22,
  0xce88, 0xce88, 0xd11d, 0xd11d, 0xd3df, 0xd3df, 0xd6cc, 0xd6cc, 0xd9e1, 0xd9e1, 0xdd1a, 0xdd1a, 0xe075, 0xe075, 0xe3ee, 0xe3ee,
  0xe783, 0xe783, 0xeb2f, 0xeb2f, 0xeeef, 0xeeef, 0xf2bf, 0xf2bf, 0xf69d, 0xf69d, 0xfa83, 0xfa83, 0xfe6e, 0xfe6e, 0x025b, 0x025b,
  0x0645, 0x0645, 0x0a2a, 0x0a2a, 0x0e05, 0x0e05, 0x11d3, 0x11d3, 0x158f, 0x158f, 0x1936, 0x1936, 0x1cc6, 0x1cc6, 0x2039, 0x2039,
  0x238e, 0x238e, 0x26c0, 0x26c0, 0x29cd, 0x29cd, 0x2cb1, 0x2cb1, 0x2f6b, 0x2f6b, 0x31f7, 0x31f7, 0x3452, 0x3452, 0x367c, 0x367c,
  0x3870, 0x3870, 0x3a2f, 0x3a2f, 0x3bb5, 0x3bb5, 0x3d02, 0x3d02, 0x3e14, 0x3e14, 0x3eea, 0x3eea, 0x3f84, 0x3f84, 0x3fe0, 0x3fe0,
  0x3fff, 0x3fff, 0x3fe0, 0x3fe0, 0x3f84, 0x3f84, 0x3eea, 0x3eea, 0x3e14, 0x3e14, 0x3d02, 0x3d02, 0x3bb5, 0x3bb5, 0x3a2f, 0x3a2f,
  0x3870, 0x3870, 0x367c, 0x367c, 0x3452, 0x3452, 0x31f7, 0x31f7, 0x2f6b, 0x2f6b, 0x2cb1, 0x2cb1, 0x29cd, 0x29cd, 0x26c0, 0x26c0,
  0x238e, 0x238e, 0x2039, 0x2039, 0x1cc6, 0x1cc6, 0x1936, 0x1936, 0x158f, 0x158f, 0x11d3, 0x11d3, 0x0e05, 0x0e05, 0x0a2a, 0x0a2a,
  0x0645, 0x0645, 0x025b, 0x025b, 0xfe6e, 0xfe6e, 0xfa83, 0xfa83, 0xf69d, 0xf69d, 0xf2bf, 0xf2bf, 0xeeef, 0xeeef, 0xeb2f, 0xeb2f,
  0xe783, 0xe783, 0xe3ee, 0xe3ee, 0xe075, 0xe075, 0xdd1a, 0xdd1a, 0xd9e1, 0xd9e1, 0xd6cc, 0xd6cc, 0xd3df, 0xd3df, 0xd11d, 0xd11d,
  0xce88, 0xce88, 0xcc22, 0xcc22, 0xc9ef, 0xc9ef, 0xc7ef, 0xc7ef, 0xc626, 0xc626, 0xc494, 0xc494, 0xc33c, 0xc33c, 0xc21e, 0xc21e,
  0xc13c, 0xc13c, 0xc096, 0xc096, 0xc02d, 0xc02d, 0xc002, 0xc002, 0xc015, 0xc015, 0xc065, 0xc065, 0xc0f2, 0xc0f2, 0xc1bc, 0xc1bc,
  0xc2c2, 0xc2c2, 0xc404, 0xc404, 0xc57f, 0xc57f, 0xc732, 0xc732, 0xc91c, 0xc91c, 0xcb3b, 0xcb3b, 0xcd8d, 0xcd8d, 0xd00f, 0xd00f,
  0xd2c0, 0xd2c0, 0xd59c, 0xd59c, 0xd8a1, 0xd8a1, 0xdbcc, 0xdbcc, 0xdf1a, 0xdf1a, 0xe287, 0xe287, 0xe611, 0xe611, 0xe9b4, 0xe9b4,
  0xed6d, 0xed6d, 0xf137, 0xf137, 0xf510, 0xf510, 0xf8f3, 0xf8f3, 0xfcdd, 0xfcdd, 0x00c9, 0x00c9, 0x04b5, 0x04b5, 0x089c, 0x089c,
  0x0c7c, 0x0c7c, 0x104f, 0x104f, 0x1413, 0x1413, 0x17c3, 0x17c3, 0x1b5c, 0x1b5c, 0x1edb, 0x1edb, 0x223d, 0x223d, 0x257d, 0x257d,
  0x2899, 0x2899, 0x2b8e, 0x2b8e, 0x2e59, 0x2e59, 0x30f8, 0x30f8, 0x3367, 0x3367, 0x35a5, 0x35a5, 0x37af, 0x37af, 0x3983, 0x3983,
  0x3b20, 0x3b20, 0x3c84, 0x3c84, 0x3dae, 0x3dae, 0x3e9c, 0x3e9c, 0x3f4e, 0x3f4e, 0x3fc3, 0x3fc3, 0x3ffa, 0x3ffa, 0x3ff4, 0x3ff4,
  0x3fb0, 0x3fb0, 0x3f2f, 0x3f2f, 0x3e71, 0x3e71, 0x3d77, 0x3d77, 0x3c41, 0x3c41, 0x3ad2, 0x3ad2, 0x392a, 0x392a, 0x374a, 0x374a,
  0x3536, 0x3536, 0x32ee, 0x32ee, 0x3075, 0x3075, 0x2dce, 0x2dce, 0x2afa, 0x2afa, 0x27fd, 0x27fd, 0x24d9, 0x24d9, 0x2192, 0x2192,
  0x1e2b, 0x1e2b, 0x1aa6, 0x1aa6, 0x1708, 0x1708, 0x1353, 0x1353, 0x0f8c, 0x0f8c, 0x0bb6, 0x0bb6, 0x07d5, 0x07d5, 0x03ec, 0x03ec,
  0x0000, 0x0000, 0xfc14, 0xfc14, 0xf82b, 0xf82b, 0xf44a, 0xf44a, 0xf074, 0xf074, 0xecad, 0xecad, 0xe8f8, 0xe8f8, 0xe55a, 0xe55a,
  0xe1d5, 0xe1d5, 0xde6e, 0xde6e, 0xdb27, 0xdb27, 0xd803, 0xd803, 0xd506, 0xd506, 0xd232, 0xd232, 0xcf8b, 0xcf8b, 0xcd12, 0xcd12,
  0xcaca, 0xcaca, 0xc8b6, 0xc8b6, 0xc6d6, 0xc6d6, 0xc52e, 0xc52e, 0xc3bf, 0xc3bf, 0xc289, 0xc289, 0xc18f, 0xc18f, 0xc0d1, 0xc0d1,
  0xc050, 0xc050, 0xc00c, 0xc00c, 0xc006, 0xc006, 0xc03d, 0xc03d, 0xc0b2, 0xc0b2, 0xc164, 0xc164, 0xc252, 0xc252, 0xc37c, 0xc37c,
  0xc4e0, 0xc4e0, 0xc67d, 0xc67d, 0xc851, 0xc851, 0xca5b, 0xca5b, 0xcc99, 0xcc99, 0xcf08, 0xcf08, 0xd1a7, 0xd1a7, 0xd472, 0xd472,
  0xd767, 0xd767, 0xda83, 0xda83, 0xddc3, 0xddc3, 0xe125, 0xe125, 0xe4a4, 0xe4a4, 0xe83d, 0xe83d, 0xebed, 0xebed, 0xefb1, 0xefb1,
  0xf384, 0xf384, 0xf764, 0xf764, 0xfb4b, 0xfb4b, 0xff37, 0xff37, 0x0323, 0x0323, 0x070d, 0x070d, 0x0af0, 0x0af0, 0x0ec9, 0x0ec9,
  0x1293, 0x1293, 0x164c, 0x164c, 0x19ef, 0x19ef, 0x1d79, 0x1d79, 0x20e6, 0x20e6, 0x2434, 0x2434, 0x275f, 0x275f, 0x2a64, 0x2a64,
  0x2d40, 0x2d40, 0x2ff1, 0x2ff1, 0x3273, 0x3273, 0x34c5, 0x34c5, 0x36e4, 0x36e4, 0x38ce, 0x38ce, 0x3a81, 0x3a81, 0x3bfc, 0x3bfc,
  0x3d3e, 0x3d3e, 0x3e44, 0x3e44, 0x3f0e, 0x3f0e, 0x3f9b, 0x3f9b, 0x3feb, 0x3feb, 0x3ffe, 0x3ffe, 0x3fd3, 0x3fd3, 0x3f6a, 0x3f6a,
  0x3ec4, 0x3ec4, 0x3de2, 0x3de2, 0x3cc4, 0x3cc4, 0x3b6c, 0x3b6c, 0x39da, 0x39da, 0x3811, 0x3811, 0x3611, 0x3611, 0x33de, 0x33de,
  0x3178, 0x3178, 0x2ee3, 0x2ee3, 0x2c21, 0x2c21, 0x2934, 0x2934, 0x261f, 0x261f, 0x22e6, 0x22e6, 0x1f8b, 0x1f8b, 0x1c12, 0x1c12,
  0x187d, 0x187d, 0x14d1, 0x14d1, 0x1111, 0x1111, 0x0d41, 0x0d41, 0x0963, 0x0963, 0x057d, 0x057d, 0x0192, 0x0192, 0xfda5, 0xfda5,
  0xf9bb, 0xf9bb, 0xf5d6, 0xf5d6, 0xf1fb, 0xf1fb, 0xee2d, 0xee2d, 0xea71, 0xea71, 0xe6ca, 0xe6ca, 0xe33a, 0xe33a, 0xdfc7, 0xdfc7,
  0xdc72, 0xdc72, 0xd940, 0xd940, 0xd633, 0xd633, 0xd34f, 0xd34f, 0xd095, 0xd095, 0xce09, 0xce09, 0xcbae, 0xcbae, 0xc984, 0xc984,
  0xc790, 0xc790, 0xc5d1, 0xc5d1, 0xc44b, 0xc44b, 0xc2fe, 0xc2fe, 0xc1ec, 0xc1ec, 0xc116, 0xc116, 0xc07c, 0xc07c, 0xc020, 0xc020,
  0xc001, 0xc001, 0xc020, 0xc020, 0xc07c, 0xc07c, 0xc116, 0xc116, 0xc1ec, 0xc1ec, 0xc2fe, 0xc2fe, 0xc44b, 0xc44b, 0xc5d1, 0xc5d1,
  0xc790, 0xc790, 0xc984, 0xc984, 0xcbae, 0xcbae, 0xce09, 0xce09, 0xd095, 0xd095, 0xd34f, 0xd34f, 0xd633, 0xd633, 0xd940, 0xd940,
  0xdc72, 0xdc72, 0xdfc7, 0xdfc7, 0xe33a, 0xe33a, 0xe6ca, 0xe6ca, 0xea71, 0xea71, 0xee2d, 0xee2d, 0xf1fb, 0xf1fb, 0xf5d6, 0xf5d6,
  0xf9bb, 0xf9bb, 0xfda5, 0xfda5, 0x0192, 0x0192, 0x057d, 0x057d, 0x0963, 0x0963, 0x0d41, 0x0d41, 0x1111, 0x1111, 0x14d1, 0x14d1,
  0x187d, 0x187d, 0x1c12, 0x1c12, 0x1f8b, 0x1f8b, 0x22e6, 0x22e6, 0x261f, 0x261f, 0x2934, 0x2934, 0x2c21, 0x2c21, 0x2ee3, 0x2ee3,
  0x3178, 0x3178, 0x33de, 0x33de, 0x3611, 0x3611, 0x3811, 0x3811, 0x39da, 0x39da, 0x3b6c, 0x3b6c, 0x3cc4, 0x3cc4, 0x3de2, 0x3de2,
  0x3ec4, 0x3ec4, 0x3f6a, 0x3f6a, 0x3fd3, 0x3fd3, 0x3ffe, 0x3ffe, 0x3feb, 0x3feb, 0x3f9b, 0x3f9b, 0x3f0e, 0x3f0e, 0x3e44, 0x3e44,
  0x3d3e, 0x3d3e, 0x3bfc, 0x3bfc, 0x3a81, 0x3a81, 0x38ce, 0x38ce, 0x36e4, 0x36e4, 0x34c5, 0x34c5, 0x3273, 0x3273, 0x2ff1, 0x2ff1,
  0x2d40, 0x2d40, 0x2a64, 0x2a64, 0x275f, 0x275f, 0x2434, 0x2434, 0x20e6, 0x20e6, 0x1d79, 0x1d79, 0x19ef, 0x19ef, 0x164c, 0x164c,
  0x1293, 0x1293, 0x0ec9, 0x0ec9, 0x0af0, 0x0af0, 0x070d, 0x070d, 0x0323, 0x0323, 0xff37, 0xff37, 0xfb4b, 0xfb4b, 0xf764, 0xf764,
  0xf384, 0xf384, 0xefb1, 0xefb1, 0xebed, 0xebed, 0xe83d, 0xe83d, 0xe4a4, 0xe4a4, 0xe125, 0xe125, 0xddc3, 0xddc3, 0xda83, 0xda83,
  0xd767, 0xd767, 0xd472, 0xd472, 0xd1a7, 0xd1a7, 0xcf08, 0xcf08, 0xcc99, 0xcc99, 0xca5b, 0xca5b, 0xc851, 0xc851, 0xc67d, 0xc67d,
  0xc4e0, 0xc4e0, 0xc37c, 0xc37c, 0xc252, 0xc252, 0xc164, 0xc164, 0xc0b2, 0xc0b2, 0xc03d, 0xc03d, 0xc006, 0xc006, 0xc00c, 0xc00c,
  0xc050, 0xc050, 0xc0d1, 0xc0d1, 0xc18f, 0xc18f, 0xc289, 0xc289, 0xc3bf, 0xc3bf, 0xc52e, 0xc52e, 0xc6d6, 0xc6d6, 0xc8b6, 0xc8b6,
  0xcaca, 0xcaca, 0xcd12, 0xcd12, 0xcf8b, 0xcf8b, 0xd232, 0xd232, 0xd506, 0xd506, 0xd803, 0xd803, 0xdb27, 0xdb27, 0xde6e, 0xde6e,
  0xe1d5, 0xe1d5, 0xe55a, 0xe55a, 0xe8f8, 0xe8f8, 0xecad, 0xecad, 0xf074, 0xf074, 0xf44a, 0xf44a, 0xf82b, 0xf82b, 0xfc14, 0xfc14,
  0x0000, 0x0000, 0x03ec, 0x03ec, 0x07d5, 0x07d5, 0x0bb6, 0x0bb6, 0x0f8c, 0x0f8c, 0x1353, 0x1353, 0x1708, 0x1708, 0x1aa6, 0x1aa6,
  0x1e2b, 0x1e2b, 0x2192, 0x2192, 0x24d9, 0x24d9, 0x27fd, 0x27fd, 0x2afa, 0x2afa, 0x2dce, 0x2dce, 0x3075, 0x3075, 0x32ee, 0x32ee,
  0x3536, 0x3536, 0x374a, 0x374a, 0x392a, 0x392a, 0x3ad2, 0x3ad2, 0x3c41, 0x3c41, 0x3d77, 0x3d77, 0x3e71, 0x3e71, 0x3f2f, 0x3f2f,
  0x3fb0, 0x3fb0, 0x3ff4, 0x3ff4, 0x3ffa, 0x3ffa, 0x3fc3, 0x3fc3, 0x3f4e, 0x3f4e, 0x3e9c, 0x3e9c, 0x3dae, 0x3dae, 0x3c84, 0x3c84,
  0x3b20, 0x3b20, 0x3983, 0x3983, 0x37af, 0x37af, 0x35a5, 0x35a5, 0x3367, 0x3367, 0x30f8, 0x30f8, 0x2e59, 0x2e59, 0x2b8e, 0x2b8e,
  0x2899, 0x2899, 0x257d, 0x257d, 0x223d, 0x223d, 0x1edb, 0x1edb, 0x1b5c, 0x1b5c, 0x17c3, 0x17c3, 0x1413, 0x1413, 0x104f, 0x104f,
  0x0c7c, 0x0c7c, 0x089c, 0x089c, 0x04b5, 0x04b5, 0x00c9, 0x00c9, 0xfcdd, 0xfcdd, 0xf8f3, 0xf8f3, 0xf510, 0xf510, 0xf137, 0xf137,
  0xed6d, 0xed6d, 0xe9b4, 0xe9b4, 0xe611, 0xe611, 0xe287, 0xe287, 0xdf1a, 0xdf1a, 0xdbcc, 0xdbcc, 0xd8a1, 0xd8a1, 0xd59c, 0xd59c,
  0xd2c0, 0xd2c0, 0xd00f, 0xd00f, 0xcd8d, 0xcd8d, 0xcb3b, 0xcb3b, 0xc91c, 0xc91c, 0xc732, 0xc732, 0xc57f, 0xc57f, 0xc404, 0xc404,
  0xc2c2, 0xc2c2, 0xc1bc, 0xc1bc, 0xc0f2, 0xc0f2, 0xc065, 0xc065, 0xc015, 0xc015, 0xc002, 0xc002, 0xc02d, 0xc02d, 0xc096, 0xc096,
  0xc13c, 0xc13c, 0xc21e, 0xc21e, 0xc33c, 0xc33c, 0xc494, 0xc494, 0xc626, 0xc626, 0xc7ef, 0xc7ef, 0xc9ef, 0xc9ef, 0xcc22, 0xcc22,
  0xce88, 0xce88, 0xd11d, 0xd11d, 0xd3df, 0xd3df, 0xd6cc, 0xd6cc, 0xd9e1, 0xd9e1, 0xdd1a, 0xdd1a, 0xe075, 0xe075, 0xe3ee, 0xe3ee,
  0xe783, 0xe783, 0xeb2f, 0xeb2f, 0xeeef, 0xeeef, 0xf2bf, 0xf2bf, 0xf69d, 0xf69d, 0xfa83, 0xfa83, 0xfe6e, 0xfe6e, 0x025b, 0x025b,
  0x0645, 0x0645, 0x0a2a, 0x0a2a, 0x0e05, 0x0e05, 0x11d3, 0x11d3, 0x158f, 0x158f, 0x1936, 0x1936, 0x1cc6, 0x1cc6, 0x2039, 0x2039,
  0x238e, 0x238e, 0x26c0, 0x26c0, 0x29cd, 0x29cd, 0x2cb1, 0x2cb1, 0x2f6b, 0x2f6b, 0x31f7, 0x31f7, 0x3452, 0x3452, 0x367c, 0x367c,
  0x3870, 0x3870, 0x3a2f, 0x3a2f, 0x3bb5, 0x3bb5, 0x3d02, 0x3d02, 0x3e14, 0x3e14, 0x3eea, 0x3eea, 0x3f84, 0x3f84, 0x3fe0, 0x3fe0,
  0x3fff, 0x3fff, 0x3fe0, 0x3fe0, 0x3f84, 0x3f84, 0x3eea, 0x3eea, 0x3e14, 0x3e14, 0x3d02, 0x3d02, 0x3bb5, 0x3bb5, 0x3a2f, 0x3a2f,
  0x3870, 0x3870, 0x367c, 0x367c, 0x3452, 0x3452, 0x31f7, 0x31f7, 0x2f6b, 0x2f6b, 0x2cb1, 0x2cb1, 0x29cd, 0x29cd, 0x26c0, 0x26c0,
  0x238e, 0x238e, 0x2039, 0x2039, 0x1cc6, 0x1cc6, 0x1936, 0x1936, 0x158f, 0x158f, 0x11d3, 0x11d3, 0x0e05, 0x0e05, 0x0a2a, 0x0a2a,
  0x0645, 0x0645, 0x025b, 0x025b, 0xfe6e, 0xfe6e, 0xfa83, 0xfa83, 0xf69d, 0xf69d, 0xf2bf, 0xf2bf, 0xeeef, 0xeeef, 0xeb2f, 0xeb2f,
  0xe783, 0xe783, 0xe3ee, 0xe3ee, 0xe075, 0xe075, 0xdd1a, 0xdd1a, 0xd9e1, 0xd9e1, 0xd6cc, 0xd6cc, 0xd3df, 0xd3df, 0xd11d, 0xd11d,
  0xce88, 0xce88, 0xcc22, 0xcc22, 0xc9ef, 0xc9ef, 0xc7ef, 0xc7ef, 0xc626, 0xc626, 0xc494, 0xc494, 0xc33c, 0xc33c, 0xc21e, 0xc21e,
  0xc13c, 0xc13c, 0xc096, 0xc096, 0xc02d, 0xc02d, 0xc002, 0xc002, 0xc015, 0xc015, 0xc065, 0xc065, 0xc0f2, 0xc0f2, 0xc1bc, 0xc1bc,
  0xc2c2, 0xc2c2, 0xc404, 0xc404, 0xc57f, 0xc57f, 0xc732, 0xc732, 0xc91c, 0xc91c, 0xcb3b, 0xcb3b, 0xcd8d, 0xcd8d, 0xd00f, 0xd00f,
  0xd2c0, 0xd2c0, 0xd59c, 0xd59c, 0xd8a1, 0xd8a1, 0xdbcc, 0xdbcc, 0xdf1a, 0xdf1a, 0xe287, 0xe287, 0xe611, 0xe611, 0xe9b4, 0xe9b4,
  0xed6d, 0xed6d, 0xf137, 0xf137, 0xf510, 0xf510, 0xf8f3, 0xf8f3, 0xfcdd, 0xfcdd, 0x00c9, 0x00c9, 0x04b5, 0x04b5, 0x089c, 0x089c,
  0x0c7c, 0x0c7c, 0x104f, 0x104f, 0x1413, 0x1413, 0x17c3, 0x17c3, 0x1b5c, 0x1b5c, 0x1edb, 0x1edb, 0x223d, 0x223d, 0x257d, 0x257d,
  0x2899, 0x2899, 0x2b8e, 0x2b8e, 0x2e59, 0x2e59, 0x30f8, 0x30f8, 0x3367, 0x3367, 0x35a5, 0x35a5, 0x37af, 0x37af, 0x3983, 0x3983,
  0x3b20, 0x3b20, 0x3c84, 0x3c84, 0x3dae, 0x3dae, 0x3e9c, 0x3e9c, 0x3f4e, 0x3f4e, 0x3fc3, 0x3fc3, 0x3ffa, 0x3ffa, 0x3ff4, 0x3ff4,
  0x3fb0, 0x3fb0, 0x3f2f, 0x3f2f, 0x3e71, 0x3e71, 0x3d77, 0x3d77, 0x3c41, 0x3c41, 0x3ad2, 0x3ad2, 0x392a, 0x392a, 0x374a, 0x374a,
  0x3536, 0x3536, 0x32ee, 0x32ee, 0x3075, 0x3075, 0x2dce, 0x2dce, 0x2afa, 0x2afa, 0x27fd, 0x27fd, 0x24d9, 0x24d9, 0x2192, 0x2192,
  0x1e2b, 0x1e2b, 0x1aa6, 0x1aa6, 0x1708, 0x1708, 0x1353, 0x1353, 0x0f8c, 0x0f8c, 0x0bb6, 0x0bb6, 0x07d5, 0x07d5, 0x03ec, 0x03ec,
  0x0000, 0x0000, 0xfc14, 0xfc14, 0xf82b, 0xf82b, 0xf44a, 0xf44a, 0xf074, 0xf074, 0xecad, 0xecad, 0xe8f8, 0xe8f8, 0xe55a, 0xe55a,
  0xe1d5, 0xe1d5, 0xde6e, 0xde6e, 0xdb27, 0xdb27, 0xd803, 0xd803, 0xd506, 0xd506, 0xd232, 0xd232, 0xcf8b, 0xcf8b, 0xcd12, 0xcd12,
  0xcaca, 0xcaca, 0xc8b6, 0xc8b6, 0xc6d6, 0xc6d6, 0xc52e, 0xc52e, 0xc3bf, 0xc3bf, 0xc289, 0xc289, 0xc18f, 0xc18f, 0xc0d1, 0xc0d1,
  0xc050, 0xc050, 0xc00c, 0xc00c, 0xc006, 0xc006, 0xc03d, 0xc03d, 0xc0b2, 0xc0b2, 0xc164, 0xc164, 0xc252, 0xc252, 0xc37c, 0xc37c,
  0xc4e0, 0xc4e0, 0xc67d, 0xc67d, 0xc851, 0xc851, 0xca5b, 0xca5b, 0xcc99, 0xcc99, 0xcf08, 0xcf08, 0xd1a7, 0xd1a7, 0xd472, 0xd472,
  0xd767, 0xd767, 0xda83, 0xda83, 0xddc3, 0xddc3, 0xe125, 0xe125, 0xe4a4, 0xe4a4, 0xe83d, 0xe83d, 0xebed, 0xebed, 0xefb1, 0xefb1,
  0xf384, 0xf384, 0xf764, 0xf764, 0xfb4b, 0xfb4b, 0xff37, 0xff37, 0x0323, 0x0323, 0x070d, 0x070d, 0x0af0, 0x0af0, 0x0ec9, 0x0ec9,
  0x1293, 0x1293, 0x164c, 0x164c, 0x19ef, 0x19ef, 0x1d79, 0x1d79, 0x20e6, 0x20e6, 0x2434, 0x2434, 0x275f, 0x275f, 0x2a64, 0x2a64,
  0x2d40, 0x2d40, 0x2ff1, 0x2ff1, 0x3273, 0x3273, 0x34c5, 0x34c5, 0x36e4, 0x36e4, 0x38ce, 0x38ce, 0x3a81, 0x3a81, 0x3bfc, 0x3bfc,
  0x3d3e, 0x3d3e, 0x3e44, 0x3e44, 0x3f0e, 0x3f0e, 0x3f9b, 0x3f9b, 0x3feb, 0x3feb, 0x3ffe, 0x3ffe, 0x3fd3, 0x3fd3, 0x3f6a, 0x3f6a,
  0x3ec4, 0x3ec4, 0x3de2, 0x3de2, 0x3cc4, 0x3cc4, 0x3b6c, 0x3b6c, 0x39da, 0x39da, 0x3811, 0x3811, 0x3611, 0x3611, 0x33de, 0x33de,
  0x3178, 0x3178, 0x2ee3, 0x2ee3, 0x2c21, 0x2c21, 0x2934, 0x2934, 0x261f, 0x261f, 0x22e6, 0x22e6, 0x1f8b, 0x1f8b, 0x1c12, 0x1c12,
  0x187d, 0x187d, 0x14d1, 0x14d1, 0x1111, 0x1111, 0x0d41, 0x0d41, 0x0963, 0x0963, 0x057d, 0x057d, 0x0192, 0x0192, 0xfda5, 0xfda5,
  0xf9bb, 0xf9bb, 0xf5d6, 0xf5d6, 0xf1fb, 0xf1fb, 0xee2d, 0xee2d, 0xea71, 0xea71, 0xe6ca, 0xe6ca, 0xe33a, 0xe33a, 0xdfc7, 0xdfc7,
  0xdc72, 0xdc72, 0xd940, 0xd940, 0xd633, 0xd633, 0xd34f, 0xd34f, 0xd095, 0xd095, 0xce09, 0xce09, 0xcbae, 0xcbae, 0xc984, 0xc984,
  0xc790, 0xc790, 0xc5d1, 0xc5d1, 0xc44b, 0xc44b, 0xc2fe, 0xc2fe, 0xc1ec, 0xc1ec, 0xc116, 0xc116, 0xc07c, 0xc07c, 0xc020, 0xc020,
  0xc001, 0xc001, 0xc020, 0xc020, 0xc07c, 0xc07c, 0xc116, 0xc116, 0xc1ec, 0xc1ec, 0xc2fe, 0xc2fe, 0xc44b, 0xc44b, 0xc5d1, 0xc5d1,
  0xc790, 0xc790, 0xc984, 0xc984, 0xcbae, 0xcbae, 0xce09, 0xce09, 0xd095, 0xd095, 0xd34f, 0xd34f, 0xd633, 0xd633, 0xd940, 0xd940,
  0xdc72, 0xdc72, 0xdfc7, 0xdfc7, 0xe33a, 0xe33a, 0xe6ca, 0xe6ca, 0xea71, 0xea71, 0xee2d, 0xee2d, 0xf1fb, 0xf1fb, 0xf5d6, 0xf5d6,
  0xf9bb, 0xf9bb, 0xfda5, 0xfda5, 0x0192, 0x0192, 0x057d, 0x057d, 0x0963, 0x0963, 0x0d41, 0x0d41, 0x1111, 0x1111, 0x14d1, 0x14d1,
  0x187d, 0x187d, 0x1c12, 0x1c12, 0x1f8b, 0x1f8b, 0x22e6, 0x22e6, 0x261f, 0x261f, 0x2934, 0x2934, 0x2c21, 0x2c21, 0x2ee3, 0x2ee3,
  0x3178, 0x3178, 0x33de, 0x33de, 0x3611, 0x3611, 0x3811, 0x3811, 0x39da, 0x39da, 0x3b6c, 0x3b6c, 0x3cc4, 0x3cc4, 0x3de2, 0x3de2,
  0x3ec4, 0x3ec4, 0x3f6a, 0x3f6a, 0x3fd3, 0x3fd3, 0x3ffe, 0x3ffe, 0x3feb, 0x3feb, 0x3f9b, 0x3f9b, 0x3f0e, 0x3f0e, 0x3e44, 0x3e44,
  0x3d3e, 0x3d3e, 0x3bfc, 0x3bfc, 0x3a81, 0x3a81, 0x38ce, 0x38ce, 0x36e4, 0x36e4, 0x34c5, 0x34c5, 0x3273, 0x3273, 0x2ff1, 0x2ff1,
  0x2d40, 0x2d40, 0x2a64, 0x2a64, 0x275f, 0x275f, 0x2434, 0x2434, 0x20e6, 0x20e6, 0x1d79, 0x1d79, 0x19ef, 0x19ef, 0x164c, 0x164c,
  0x1293, 0x1293, 0x0ec9, 0x0ec9, 0x0af0, 0x0af0, 0x070d, 0x070d, 0x0323, 0x0323, 0xff37, 0xff37, 0xfb4b, 0xfb4b, 0xf764, 0xf764,
  0xf384, 0xf384, 0xefb1, 0xefb1, 0xebed, 0xebed, 0xe83d, 0xe83d, 0xe4a4, 0xe4a4, 0xe125, 0xe125, 0xddc3, 0xddc3, 0xda83, 0xda83,
  0xd767, 0xd767, 0xd472, 0xd472, 0xd1a7, 0xd1a7, 0xcf08, 0xcf08, 0xcc99, 0xcc99, 0xca5b, 0xca5b, 0xc851, 0xc851, 0xc67d, 0xc67d,
  0xc4e0, 0xc4e0, 0xc37c, 0xc37c, 0xc252, 0xc252, 0xc164, 0xc164, 0xc0b2, 0xc0b2, 0xc03d, 0xc03d, 0xc006, 0xc006, 0xc00c, 0xc00c,
  0xc050, 0xc050, 0xc0d1, 0xc0d1, 0xc18f, 0xc18f, 0xc289, 0xc289, 0xc3bf, 0xc3bf, 0xc52e, 0xc52e, 0xc6d6, 0xc6d6, 0xc8b6, 0xc8b6,
  0xcaca, 0xcaca, 0xcd12, 0xcd12, 0xcf8b, 0xcf8b, 0xd232, 0xd232, 0xd506, 0xd506, 0xd803, 0xd803, 0xdb27, 0xdb27, 0xde6e, 0xde6e,
  0xe1d5, 0xe1d5, 0xe55a, 0xe55a, 0xe8f8, 0xe8f8, 0xecad, 0xecad, 0xf074, 0xf074, 0xf44a, 0xf44a, 0xf82b, 0xf82b, 0xfc14, 0xfc14
};

static int cmd_hifiberry(int argc, const cmd_args *argv);

STATIC_COMMAND_START
STATIC_COMMAND("hifiberry", "Play sound on external Hifiberry card", &cmd_hifiberry)
STATIC_COMMAND_END(hifiberry);

/* spin lock for callback */
static spin_lock_t cb_lock;

/* event for audio out confirmation */
static event_t audioout_event;

/* event for audio in ready */
static event_t audioin_event;

/* Type of sound to generate */
enum sound_type {
    SND_SINEWAVE,
    SND_SQUARE,
    SND_SAW,
};

/* callback for SAI -> DAC */
static int dac_sai_cb(sai_cb_evt_t evt, void *data, void *cookie)
{
    spin_lock_saved_state_t lock_state;
    spin_lock_irqsave(&cb_lock, lock_state);

    switch (evt) {
        case SAI_EVENT_PERIOD_ELAPSED:
            event_signal(&audioout_event, false);
            break;
        case SAI_EVENT_ACTIVE:
            printlk(LK_INFO, "SAI_EVENT_ACTIVE\n");
            break;
        case SAI_EVENT_ERROR:
            printlk(LK_INFO, "SAI_EVENT_ERROR\n");
            break;
        case SAI_EVENT_DRAIN:
            printlk(LK_INFO, "SAI_EVENT_DRAIN\n");
            break;
        default:
            printlk(LK_NOTICE, "%s:%d: Unhandled event (%d) received\n",
                    __PRETTY_FUNCTION__, __LINE__, evt);
            break;
    };

    spin_unlock_irqrestore(&cb_lock, lock_state);
    return 0;
}

static void print_usage(const char *app_name)
{
    printf("Usage:\n\t%s play <sine | square | saw> [samplerate]\n", app_name);
    printf("\t%s record [samplerate]\n", app_name);
    printf("\t%s dtmf [samplerate] [dtmf_left dtmf_right]\n", app_name);
    printf("Example: %s play sine 48000\n", app_name);
    printf("         %s dtmf 48000 1234567890ABCD#* *#DCBA0987654321\n", app_name);
}

struct sink_thread_args_t {
    struct device *sai_dev;
    char **audio_buf_list;
    uint32_t audio_size;
    int *busy_index;
};

static int sink_entry(void *arg)
{
    struct sink_thread_args_t *params = arg;
    int index = 0;

    while (true) {
        /* wait for data available from source */
        event_wait(&audioin_event);
        event_unsignal(&audioin_event);

        *(params->busy_index) = index;
        class_sai_write(params->sai_dev, params->audio_buf_list[index], params->audio_size);

        index ^= 1;
    }

    return 0;
}

static int cmd_hifiberry_record(int argc, const cmd_args *argv)
{
    status_t ret = NO_ERROR;
    struct device *sai_dev;
    struct device *pcm186x_dev, *pcm512x_dev;
    sai_format_t sai_rx_fmt, sai_tx_fmt;
    adc_audio_hw_params_t adc_params;
    dac_audio_hw_params_t pcm512x_params;
    int sample_rate = REC_AUDIO_SRATE;
    char *audio_buf;
    char *audio_buf_list[2];
    int index = 0, busy_index;

    /* Optional argument: sample rate */
    if (argc > 2)
        sample_rate = argv[2].u;

    /* Get audio buffer */
    audio_buf = malloc(REC_AUDIO_PERIOD_BYTES * 2);
    ASSERT(audio_buf);
    audio_buf_list[0] = audio_buf;
    audio_buf_list[1] = audio_buf + REC_AUDIO_PERIOD_BYTES;

    /* Initialize sync objects */
    spin_lock_init(&cb_lock);
    event_init(&audioout_event, false, 0);
    event_init(&audioin_event, false, 0);

    /*
     * SAI5 is connected to DAC PCM512x and ADC PCM186x.
     * We configure SAI5 in RX to read audio data from PCM186x and
     * SAI5 in TX to write audio data to PCM512x.
     * PCM512x provides clock for PCM186x.
     */

    /* get SAI5 dev by bus id */
    sai_dev = class_sai_get_device_by_id(APP_SAI5_BUSID);
    ASSERT(sai_dev != NULL);

    /* get the PCM186x dev by bus id */
    pcm186x_dev = class_adc_get_device_by_id(APP_PCM186X_BUSID);
    ASSERT(pcm186x_dev != NULL);

    /* get the PCM512x dev by bus id */
    pcm512x_dev = class_dac_get_device_by_id(APP_PCM512X_BUSID);
    ASSERT(pcm512x_dev != NULL);

    ret = class_sai_open(sai_dev, true /* is_rx */);
    if (ret) goto free_audio_buf;

    ret = class_sai_open(sai_dev, false /* is_rx */);
    if (ret) goto close_sai_rx;

    /* codec (adc) setup */
    ret = class_adc_open(pcm186x_dev);
    if (ret) goto close_sai_tx;
    adc_params.pcm_fmt = DAC_AUDIO_PCM_FMT_32;
    adc_params.fmt = DAC_AUDIO_FMT_I2S;
    adc_params.pkt = DAC_AUDIO_PKT_PCM;
    adc_params.num_ch = 2;
    adc_params.rate = sample_rate;
    ret = class_adc_set_format(pcm186x_dev, &adc_params);
    if (ret) goto close_adc;

    /* pcm512x setup */
    /* note: dac must be opened because on Hifiberry DAC+ ADC Pro, the ADC relies
     * on the DAC clock */
    ret = class_dac_open(pcm512x_dev);
    if (ret) goto close_adc;
    pcm512x_params.pcm_fmt = DAC_AUDIO_PCM_FMT_32;
    pcm512x_params.fmt = DAC_AUDIO_FMT_I2S;
    pcm512x_params.pkt = DAC_AUDIO_PKT_PCM;
    pcm512x_params.num_ch = 2;
    pcm512x_params.num_slots = 2;
    pcm512x_params.rate = sample_rate;
    ret = class_dac_set_format(pcm512x_dev, &pcm512x_params);
    if (ret) goto close_pcm512x;

    /* setup the callback for tx */
    ret = class_sai_set_callback(sai_dev, dac_sai_cb, NULL, false);
    if (ret) goto close_pcm512x;

    /* SAI TX setup */
    sai_tx_fmt.sai_protocol = 2; /* I2S */
    sai_tx_fmt.sampleRate_Hz = sample_rate;
    sai_tx_fmt.bitWidth = REC_AUDIO_BITWIDTH;
    sai_tx_fmt.num_channels = 2; /* stereo */
    sai_tx_fmt.num_slots = 2;
    sai_tx_fmt.period_size = REC_PERIOD_SIZE; /* frames per period */
    sai_tx_fmt.polarity = SAI_BITCLOCK_POLARITY_ACTIVE_LOW;
    sai_tx_fmt.master_slave = ksai_Slave;
    sai_tx_fmt.bitclock_source = kSAI_BClkSourceMclkDiv;
    ret = class_sai_setup(sai_dev, false, &sai_tx_fmt);
    if (ret) goto close_pcm512x;

    /* SAI RX setup */
    sai_rx_fmt.sai_protocol = 2; /* I2S */
    sai_rx_fmt.sampleRate_Hz = sample_rate;
    sai_rx_fmt.bitWidth = REC_AUDIO_BITWIDTH;
    sai_rx_fmt.num_channels = 2; /* stereo */
    sai_rx_fmt.num_slots = 2;
    sai_rx_fmt.period_size = REC_PERIOD_SIZE; /* frames per period */
    sai_rx_fmt.polarity = SAI_BITCLOCK_POLARITY_ACTIVE_LOW;
    sai_rx_fmt.master_slave = ksai_Slave;
    sai_rx_fmt.bitclock_source = kSAI_BClkSourceBusclk;
    ret = class_sai_setup(sai_dev, true, &sai_rx_fmt);
    if (ret) goto close_pcm512x;

    /* start SAI and dma, data filling in the cb */
    ret = class_sai_start(sai_dev, true);
    if (ret) goto close_pcm512x;
    ret = class_sai_start(sai_dev, false);
    if (ret) goto stop_sai_rx;

    printlk(LK_NOTICE, "sample_rate: %d\n", sample_rate);

    /* Prepare thread for audio sink */
    thread_t *sink_thread;
    struct sink_thread_args_t sink_params;
    sink_params.sai_dev = sai_dev;
    sink_params.audio_buf_list = audio_buf_list;
    sink_params.audio_size = REC_AUDIO_PERIOD_BYTES;
    sink_params.busy_index = &busy_index;
    sink_thread = thread_create("sink_thread", sink_entry, &sink_params, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
    thread_resume(sink_thread);

    while (true) {
        /* read audio buffer */
        class_sai_read(sai_dev, audio_buf_list[index], REC_AUDIO_PERIOD_BYTES);

        index ^= 1;

        /* signal sink that thread data is available from source */
        event_signal(&audioin_event, false);

        if (busy_index == index) {
            /* wait for all data sent */
            event_wait(&audioout_event);
            event_unsignal(&audioout_event);
        }
    }

stop_sai_tx:
    ret = class_sai_stop(sai_dev, false);
    ASSERT(ret == 0);

stop_sai_rx:
    ret = class_sai_stop(sai_dev, true);
    ASSERT(ret == 0);

close_pcm512x:
    ret = class_dac_close(pcm512x_dev);
    ASSERT(ret == 0);

close_adc:
    ret = class_adc_close(pcm186x_dev);
    ASSERT(ret == 0);

close_sai_tx:
    ret = class_sai_close(sai_dev, false);
    ASSERT(ret == 0);

close_sai_rx:
    ret = class_sai_close(sai_dev, true);
    ASSERT(ret == 0);

free_audio_buf:
    free(audio_buf);

end:
    return (int)ret;
}

static int cmd_hifiberry_play(int argc, const cmd_args *argv)
{
    status_t ret;
    struct device *sai_dev, *dac_dev;
    sai_format_t sai_fmt;
    dac_audio_hw_params_t dac_params;
    char *audio_buf;
    int sample_rate = PLAY_AUDIO_SRATE, i = 0;
    enum sound_type snd_type;
    lk_time_t time_start;

    if (argc <= 2) {
        printf("Not enough arguments.\n");
        print_usage(argv[0].str);
        ret = ERR_INVALID_ARGS;
        goto end;
    }

   /* Parse sound type argument */
    if (!strncmp(argv[2].str, "sine", strlen("sine"))) {
        snd_type = SND_SINEWAVE;
    }
    else if (!strncmp(argv[2].str, "square", strlen("square"))) {
        snd_type = SND_SQUARE;
    }
    else if (!strncmp(argv[2].str, "saw", strlen("saw"))) {
        snd_type = SND_SAW;
    }
    else {
        printf("%s: not a valid argument.\n", argv[2].str);
        print_usage(argv[0].str);
        ret = ERR_INVALID_ARGS;
        goto end;
    }

    /* Get audio buffer */
    audio_buf = malloc(PLAY_AUDIO_PERIOD_BYTES);
    ASSERT(audio_buf);

    /* Optional argument: sample rate */
    if (argc > 3)
        sample_rate = argv[3].u;

    /* Initialize sync objects */
    spin_lock_init(&cb_lock);
    event_init(&audioout_event, false, 0);

    /* get SAI5 dev by bus id */
    sai_dev = class_sai_get_device_by_id(APP_SAI5_BUSID);
    ASSERT(sai_dev != NULL);

    /* get the PCM512x dev by bus id */
    dac_dev = class_dac_get_device_by_id(APP_PCM512X_BUSID);
    ASSERT(dac_dev != NULL);

    ret = class_sai_open(sai_dev, false /* is_rx */);
    if (ret) goto free_audio_buf;

    /* codec (dac) setup */
    ret = class_dac_open(dac_dev);
    if (ret) goto close_sai;

    dac_params.pcm_fmt = DAC_AUDIO_PCM_FMT_16;
    dac_params.fmt = DAC_AUDIO_FMT_I2S;
    dac_params.pkt = DAC_AUDIO_PKT_PCM;
    dac_params.num_ch = 2;
    dac_params.num_slots = 2;
    dac_params.rate = sample_rate;

    ret = class_dac_set_format(dac_dev, &dac_params);
    if (ret) goto close_dac;

    /* setup the callback for tx */
    ret = class_sai_set_callback(sai_dev, dac_sai_cb, NULL, false);
    if (ret) goto close_dac;

    /* SAI5 setup */
    sai_fmt.sai_protocol = 2; /* I2S */
    sai_fmt.sampleRate_Hz = sample_rate; /* sample rate */
    sai_fmt.bitWidth = PLAY_AUDIO_BITWIDTH;
    sai_fmt.num_channels = 2; /* stereo */
    sai_fmt.num_slots = 2;
    sai_fmt.period_size = PLAY_PERIOD_SIZE; /* frames per period */
    sai_fmt.polarity = SAI_BITCLOCK_POLARITY_ACTIVE_LOW;
    sai_fmt.master_slave = ksai_Slave;
    sai_fmt.bitclock_source = kSAI_BClkSourceBusclk;

    ret = class_sai_setup(sai_dev, false, &sai_fmt);
    if (ret) goto close_dac;

    /* start SAI and dma, data filling in the cb */
    ret = class_sai_start(sai_dev, false);
    if (ret) goto close_dac;

    time_start = current_time();
    while (true) {
        if (current_time() - time_start >= PLAY_LENGTH_MS)
            break;

        /* prepare audio buffer */
        if (snd_type == SND_SINEWAVE) {
            memcpy(audio_buf, ((uint8_t *)sinewave) + i, PLAY_AUDIO_PERIOD_BYTES);
            i += PLAY_AUDIO_PERIOD_BYTES;
            if ((i + PLAY_AUDIO_PERIOD_BYTES) > (int)sizeof(sinewave)) i = 0;
        }
        else if (snd_type == SND_SQUARE) {
            static int k = 0;
            uint16_t *ptr = (uint16_t *)audio_buf;
            for (i = 0; i < PLAY_AUDIO_PERIOD_BYTES / 2; i++) {
                *ptr++ = k ? 0x2000 : 0xfe000;
            }
            k ^= 1;
        }
        else {
            uint16_t *ptr = (uint16_t *)audio_buf;
            for (i = 0; i < PLAY_AUDIO_PERIOD_BYTES / 2; i++) {
                *ptr++ = i;
            }
        }

        /* copy audio buffer */
        class_sai_write(sai_dev, audio_buf, PLAY_AUDIO_PERIOD_BYTES);

        /* wait for all data sent */
        event_wait(&audioout_event);
        event_unsignal(&audioout_event);
    }

    /* stop SAI and dma */
    ret = class_sai_stop(sai_dev, false);
    ASSERT(ret == 0);

close_dac:
    ret = class_dac_close(dac_dev);
    ASSERT(ret == 0);

close_sai:
    ret = class_sai_close(sai_dev, false);
    ASSERT(ret == 0);

free_audio_buf:
    free(audio_buf);

end:
    return (int)ret;
}

static int cmd_hifiberry_dtmf(int argc, const cmd_args *argv)
{
    status_t ret;
    struct device *sai_dev, *dac_dev;
    sai_format_t sai_fmt;
    dac_audio_hw_params_t dac_params;
    uint32_t *audio_buf;
    ssize_t audio_buf_size;
    int sample_rate = DTMF_AUDIO_SRATE;
    const char default_dtmf_l_seq[] = "1123ABCD0123456789*#";
    const char default_dtmf_r_seq[] = "#*9876543210DCBA3211";
    const char *dtmf_l_seq = default_dtmf_l_seq;
    const char *dtmf_r_seq = default_dtmf_r_seq;
    unsigned int dtmf_seq_idx = 0;

    /* Parse command line parameters */
    switch (argc) {
        case 5:
            /* Optional arguments: tones for left and right channels */
            dtmf_l_seq = argv[3].str;
            dtmf_r_seq = argv[4].str;
            if (strlen(dtmf_l_seq) != strlen(dtmf_r_seq)) {
                printf("Tone sequence must be same size for left and right channels!\n");
                ret = ERR_INVALID_ARGS;
                goto end;
            }
            /* intentional fallthrough */
        case 3:
            /* Optional argument: sample rate */
            sample_rate = argv[2].u;
            break;
        case 2:
            break;
        default:
            printf("Not enough arguments.\n");
            print_usage(argv[0].str);
            ret = ERR_INVALID_ARGS;
            goto end;
    }

    printf("Playing following DTMF sequence at %d Hz:\n", sample_rate);
    printf("\tleft channel:  %s\n", dtmf_l_seq);
    printf("\tright channel: %s\n", dtmf_r_seq);

    /* Calculate size of audio buffer for tone duration */
    audio_buf_size = sample_rate * 2 * 4 * DTMF_TONE_DURATION_MS / 1000;

    /* Get audio buffer */
    audio_buf = malloc(audio_buf_size);
    ASSERT(audio_buf);

    /* Initialize sync objects */
    spin_lock_init(&cb_lock);
    event_init(&audioout_event, false, 0);

    /* get SAI5 dev by bus id */
    sai_dev = class_sai_get_device_by_id(APP_SAI5_BUSID);
    ASSERT(sai_dev != NULL);

    /* get the PCM512x dev by bus id */
    dac_dev = class_dac_get_device_by_id(APP_PCM512X_BUSID);
    ASSERT(dac_dev != NULL);

    ret = class_sai_open(sai_dev, false /* is_rx */);
    if (ret) goto free_audio_buf;

    /* codec (dac) setup */
    ret = class_dac_open(dac_dev);
    if (ret) goto close_sai;

    dac_params.pcm_fmt = DAC_AUDIO_PCM_FMT_32;
    dac_params.fmt = DAC_AUDIO_FMT_I2S;
    dac_params.pkt = DAC_AUDIO_PKT_PCM;
    dac_params.num_ch = 2;
    dac_params.num_slots = 2;
    dac_params.rate = sample_rate;

    ret = class_dac_set_format(dac_dev, &dac_params);
    if (ret) goto close_dac;

    /* setup the callback for tx */
    ret = class_sai_set_callback(sai_dev, dac_sai_cb, NULL, false);
    if (ret) goto close_dac;

    /* SAI5 setup */
    sai_fmt.sai_protocol = 2; /* I2S */
    sai_fmt.sampleRate_Hz = sample_rate; /* sample rate */
    sai_fmt.bitWidth = DTMF_AUDIO_BITWIDTH;
    sai_fmt.num_channels = 2; /* stereo */
    sai_fmt.num_slots = 2;
    sai_fmt.period_size = sample_rate * DTMF_TONE_DURATION_MS / 1000; /* frames per period */
    sai_fmt.polarity = SAI_BITCLOCK_POLARITY_ACTIVE_LOW;
    sai_fmt.master_slave = ksai_Slave;
    sai_fmt.bitclock_source = kSAI_BClkSourceBusclk;

    ret = class_sai_setup(sai_dev, false, &sai_fmt);
    if (ret) goto close_dac;

    /* start SAI and dma, data filling in the cb */
    ret = class_sai_start(sai_dev, false);
    if (ret) goto close_dac;

    while (dtmf_seq_idx < strlen(dtmf_l_seq)) {
        /* prepare audio buffer */
        generate_dtmf_tone(audio_buf, dtmf_l_seq[dtmf_seq_idx], dtmf_r_seq[dtmf_seq_idx], sample_rate);
        dtmf_seq_idx++;

        /* copy audio buffer */
        class_sai_write(sai_dev, audio_buf, audio_buf_size);

        /* wait for all data sent */
        event_wait(&audioout_event);
        event_unsignal(&audioout_event);

        /* send blank buffer */
        memset(audio_buf, 0, audio_buf_size);

        /* copy audio buffer */
        class_sai_write(sai_dev, audio_buf, audio_buf_size);

        /* wait for all data sent */
        event_wait(&audioout_event);
        event_unsignal(&audioout_event);
    }

    /* stop SAI and dma */
    ret = class_sai_stop(sai_dev, false);
    ASSERT(ret == 0);

close_dac:
    ret = class_dac_close(dac_dev);
    ASSERT(ret == 0);

close_sai:
    ret = class_sai_close(sai_dev, false);
    ASSERT(ret == 0);

free_audio_buf:
    free(audio_buf);

end:
    return (int)ret;
}

static int cmd_hifiberry(int argc, const cmd_args *argv)
{
    status_t ret = NO_ERROR;

    if (argc < 2) {
        printf("Not enough arguments.\n");
        print_usage(argv[0].str);
        ret = ERR_INVALID_ARGS;
        goto end;
    }

    /* Parse 'play' / 'record' argument */
    if (!strncmp(argv[1].str, "play", strlen("play"))) {
        ret = cmd_hifiberry_play(argc, argv);
    }
    else if (!strncmp(argv[1].str, "record", strlen("record"))) {
        ret = cmd_hifiberry_record(argc, argv);
    }
    else if (!strncmp(argv[1].str, "dtmf", strlen("dtmf"))) {
        ret = cmd_hifiberry_dtmf(argc, argv);
    }
    else {
        printf("Syntax error.\n");
        print_usage(argv[0].str);
        ret = ERR_INVALID_ARGS;
    }

end:
    return (int)ret;
}

APP_START(hifiberry)
    .flags = 0,
APP_END

#endif // WITH_APP_CONSOLE
